# 704. Binary Search

[problem](https://leetcode.com/problems/binary-search/description/)

Binary search is very effective for searching an ordred array with O(logn) time complexity.

Here there's two things to consider: 
- 1. use double pointers : left and right, 
- 2. the search interval of the array
  - both close interval [left, right]
  - left close, right open [left, right)

### Frist method
let's discuss the first method [left, right]:
Then we have to decide the condition for the left and right pointers for the loop. Obviously, we expect left < right but, what about left == right? 
if [1 ,1], that is reasonable. 

So we can determine the loop works while left <= right. 
if the target > nums[mid], we will update the left pointer. Given that target > nums[mid], and we are searching a closed interval, then target must be within an interval [mid+1, right]
if target < nums[mid], we update the right pointer.Given that target < nums[mid], target must be within an interval [left, mid-1]


```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        
        left = 0
        right = len(nums)-1
        while left <= right:
            mid = left + (right-left)//2   
            #  [1,2,3,4,5]   4,  l =0, r =4, mid = 2, 
            #   [0] 0 , l=r =0, mid =0
            #  [2, 4] 4, l =0, r=1, mid = 0
            if  target > nums[mid]:
                left = mid+1
            elif target < nums[mid]:
                right = mid-1
            else:
                return mid

        else:
            return -1
        

```


One more thing: it is possible that when left + right two int's sum might cause an overflow. So we can write mid = left + (right-left)//2

### Another Method
The while loop works when left < right.
Then the interval is [left, right) which means, the right is not included in the searching interval.
thus right = len(nums)

if the target > nums[mid], we will update the left pointer. Given that target > nums[mid], and we are searching a closed left, then target must be within an interval [mid+1, right)
if target < nums[mid], we update the right pointer. Then right= mid as we actually search from left to right-1
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)
        while left < right:
            mid = left + (right-left)//2   
            if  target > nums[mid]:
                left = mid+1
            elif target < nums[mid]:
                right = mid
            else:
                return mid

        else:
            return -1

```

As for the time complexity, 
assume that len(nums) =n 
1st iteration , find the new mid:   new lenght n//2
2nd iteration ,n//2^2
3rd iteration ,m//(2^3)
assume at 
m th iteration  n//(2^m)  only has one element, then T(n//(2^m))  = T（1）

m = logn




