# 704. Binary Search

[problem](https://leetcode.com/problems/binary-search/description/)

Binary search is very effective for searching an ordred array with O(logn) time complexity.

Here there's two things to consider: 
- 1. use double pointers : left and right, 
- 2. the search interval of the array
  - both close interval [left, right]
  - left close, right open [left, right)

### Frist method
let's discuss the first method [left, right]:
Then we have to decide the condition for the left and right pointers for the loop. Obviously, we expect left < right but, what about left == right? 
if [1 ,1], that is reasonable. 

So we can determine the loop works while left <= right. 
if the target > nums[mid], we will update the left pointer. Given that target > nums[mid], and we are searching a closed interval, then target must be within an interval [mid+1, right]
if target < nums[mid], we update the right pointer.Given that target < nums[mid], target must be within an interval [left, mid-1]


```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        
        left = 0
        right = len(nums)-1
        while left <= right:
            mid = left + (right-left)//2   
            #  [1,2,3,4,5]   4,  l =0, r =4, mid = 2, 
            #   [0] 0 , l=r =0, mid =0
            #  [2, 4] 4, l =0, r=1, mid = 0
            if  target > nums[mid]:
                left = mid+1
            elif target < nums[mid]:
                right = mid-1
            else:
                return mid

        else:
            return -1
        

```


One more thing: it is possible that when left + right two int's sum might cause an overflow. So we can write mid = left + (right-left)//2

### Another Method
The while loop works when left < right.
Then the interval is [left, right) which means, the right is not included in the searching interval.
thus right = len(nums)

if the target > nums[mid], we will update the left pointer. Given that target > nums[mid], and we are searching a closed left, then target must be within an interval [mid+1, right)
if target < nums[mid], we update the right pointer. Then right= mid as we actually search from left to right-1
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)
        while left < right:
            mid = left + (right-left)//2   
            if  target > nums[mid]:
                left = mid+1
            elif target < nums[mid]:
                right = mid
            else:
                return mid

        else:
            return -1

```

As for the time complexity, 
assume that len(nums) =n 
1st iteration , find the new mid:   new lenght n//2
2nd iteration ,n//2^2
3rd iteration ,m//(2^3)
assume at 
m th iteration  n//(2^m)  only has one element, then T(n//(2^m))  = T（1）

m = logn


# 27. Remove Element

[problem](https://leetcode.com/problems/remove-element/description/)

The key point of this problem is that an array's elements are continous in the memory. Technically, we can't delete an individual element-that is a memory address. But we can overite the element with a new value.
### Brute Force
we can use two layers of for loop to update the array
```python
    i = 0 n = len(nums)
    for i in range(len(nums)):
        if nums[i]== val:
            for j in range(i+1, len(nums)):
            # update every element one spot ahead
                nums[j-1] = nums[j]
            i -=1
            n -=1
    return n

```
Time Complexity O(n^2)

### Two Pointer Approach
We can use two pointer to make the compexity to O(N)
set up a fast and a slow pointer pointing at the index 0. 
the fast pointer move forward one spot in each while loop, if the element == val, we do nothing, just move to the next element. if the element ！= val, we use nums[slow] to update the element, and then move the slow to the next element.

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
       #[3,2,2,3] 3
        fast = 0
        slow = 0
        while fast < len(nums):
            if nums[fast] == val:
                
                fast +=1
                
            else:
                nums[slow] = nums[fast]
                fast +=1
                slow +=1
        return slow
                
```

in summary 
    fast pointer: searching for the element in the new array, skip the unwanted elements
    slow pointer: pointing to the position where new element is updated

                

# 977. Squares of a Sorted Array
[problem](https://leetcode.com/problems/squares-of-a-sorted-array/description/)

The important point about this problem is that the array is non- decreasing and has negative values. we can use a left and right pointer to compare the squraed value and store the new elements to the result array.

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        # the list is ordered, after square, the largest element would be on the right or left, but not in the middle, so we can use one pointer on the left, other on the right 
        # compare two elements after square, and put the larger element on the right side of the new array
        l = 0
        r = len(nums)-1
        result = [float('inf')] * len(nums)
        k=len(nums)-1
        
        while l<= r:
            if nums[l]*nums[l] < nums[r]*nums[r]:
                result[k] = nums[r]*nums[r]
                r -=1
                
            else:
                result[k] = nums[l]*nums[l]
                l += 1
            k -= 1
            
        return result

```