# 203. Remove Linked List Elements
[problem](https://leetcode.com/problems/remove-linked-list-elements/description/)

delete an element from linked list, node.next = node.next.next
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

```python

class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        #build a dummyhead
        dummyhead = ListNode(next=head)
        # set up two pointers
        prev = dummyhead
        curr = head

        #when the pointer stop
        while curr:
            nxt = curr.next
            if curr.val == val:
                prev.next = nxt
            else:
                prev = curr
                
            curr = nxt
        return dummyhead.next

```

```python
 def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        #base case:
        if head == None:
            return head
        else:
            if head.val == val :
                return self.removeElements(head.next, val);
            else:
                head.next = self.removeElements(head.next, val);
        return head
```

# 707. Design Linked List
[problem](https://leetcode.com/problems/design-linked-list/description/)
This one is a little challeging for me as I have to set up a dummyhead  in the beginning, and consider insert as always interting betwee two elements. When I work with the delete function, I will need to consider the condition that prev.next is none. 
```python
class Node:
    def __init__(self,val=0):
        self.val = val
        self.next = None

class MyLinkedList:

    def __init__(self):
        # dummy head, no real value
        self.head = Node()  
        self.size = 0

        

    def get(self, index: int) -> int:
        if index<0 or index >= self.size:
            return -1
        curr = self.head.next
        for _ in range(index):            
            curr=curr.next
        return curr.val



    def addAtHead(self, val: int) -> None:
        new_head = Node(val)
        new_head.next = self.head.next
        self.head.next =  new_head
       
        self.size += 1

    def addAtTail(self, val: int) -> None:
        # new_node = Node(val)
        # curr = self.head.next
        # for i in range(self.size):
        #     curr = curr.next
        # curr.next = new_node
        # self.size += 1
        self.addAtIndex(self.size, val)
        

    def addAtIndex(self, index: int, val: int) -> None:
        # if index <0 treat it as index =0
        # if index == size, append it at the tail
        # if index > size, will not insert hte node
        if index <0:
            index = 0
        if index > self.size:
            return
        else:
            prev = self.head
            for i in range (index):
                prev = prev.next
            new_node = Node(val)
            new_node.next = prev.next
            prev.next = new_node
            self.size += 1
        

    def deleteAtIndex(self, index: int) -> None:
        if index <0:
            index = 0
        if index > self.size:
            return
        else:
            prev = self.head
            
            for i in range(index):
                
                prev = prev.next
            to_delete = prev.next
            if to_delete is None:
                return
            prev.next = to_delete.next
            
            self.size -= 1
            
        


```

# 206. Reverse Linked List
### Two pointers approach
First set up a curr pointer to the head. and then the prev pointer for the dummy head. reverse the list means
before is prev.next = curr, 
change to curr.next = prev. then the prev and curr need to move forward, 
Time Compexity O(n)
Space Compexity O(1)
```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        #base case 1->null null->1
        # dummy <-2     3   4
        #         prev curr next 
        # curr.next = prev 
        # curr = curr.next prev = prev.next
        # curr.next = prev 
        curr = head
        prev = None
        while curr:
            # store the value
            tmp = curr.next
            # reverse the list, make the pointer point to the previous element
            curr.next = prev
            # prev pointer move forward
            prev = curr
            # curr pointer move forward
            curr = tmp

        return  prev # last loop, curr= None, prev point to the new head
```

### Recursive method:
The base case is that when curr is none, then return prev (that's the same condition when the two pointers method exit the while loop)
each recursion, the prev and curr should be one step forward ( temp = curr prev = curr, curr = temp)
```python
class Solution:
        
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        return self.reverse(head,None)

    def reverse(self,curr: ListNode, prev: ListNode)->ListNode:
        #base case 1->null null->1
       #           prev curr
        
        if curr == None:
            return prev
        temp = curr.next
        curr.next = prev
        return self.reverse(temp,curr)
```