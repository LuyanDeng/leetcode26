# 209 Minimum Size Subarray Sum
[problem](https://leetcode.com/problems/minimum-size-subarray-sum/)

### Brute Force 
Since this problem ask for the minimum length of a subarray that has a sum larger or equal to the target value. We can first has for loop start with i to iterate the array (0,len(nums)), i is the starting point the subarray. 
and j is the ending point of the subarray. the for loop range is (i, len(nums))
and keep the minimum length of the subarray

```python
  
    i = 0
    j =0  
    n = len(nums)
    min_len = float('inf') # set to infinity

    for i in range(n):
        
        curr_sum = 0
        
        for j in range(i,n):
            curr_sum += nums[j]
            if curr_sum >= target:
                min_len = min(min_len, j-i+1)
                break


   return min_len if min_len!= float('inf') else 0
   
   
   ```
### Two pointers approach
we set up i and j pointers starting at 0,  i, j are the start and ending points of the sub array
if the sum of subarray < target, j will keep move forward until the subarray >= target, the length of subarray result = min (result, j-i+1)
when subarray >= target, i will move forward too, and the sum will be updated to sum - nums[i], then under the loop to chech if subarray >= target

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        left = 0
        right = 0 
        curr_sum =0
        n = len(nums)
        result = float('inf')
        while right < n:
            curr_sum += nums[right]
            while curr_sum >= target:
                result = min(result, right-left+1)
                curr_sum -= nums[left]
                left += 1
            right +=1
        return result if result != float('inf') else 0



```
I forgot to consider the corner case when there's no such subarray. 


# 59. Spiral Matrix II
1 2 3
8 9 4
7 6 5

interval strategy:
left closed, right open
n * n matrix,  
1. initial a n*n matrix 
2. set up four pointers: left=0, right=n-1,
 top= 0 
bottom =n-1
3. when iterate the matrix
   - fill the top row with value
    - fill the right col with value
    - fill the bottom row with value
     - fill the left col with value

while left <= right:
    for col in range(left,right+1):
        res[top][col] = val
        val+=1
- fill the right col with value
    top +=1
     for row in range(top, bottom+1)
        res[row][right]=val
        val += 1
    right -=1

- fill the bottom row with value
  for col in range (right, left, -1)
     res[bottom][col] = val
     val += 1
  bottom -=1
- fill the left col with value
  for row in range (bottom,top, -1)
    res[row][left] = val
    val += 1
  left += 1
2. then we disscuss when the spiral matrix stop: left > right , top > bottom

```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        # initialize a n*n matrix
        matrix = [[0]*n for _ in range(n)]
        val = 1

        #assign top, bottom, left, right pointer
        top = 0
        bottom = n-1 # row
        left = 0
        right = n-1 # column
        while left<= right:
        # fill val to the top row
            for col in range(left,right+1):
                matrix[top][col] = val
                val +=1 # val increment by 1
            top += 1 #after the first row done, top pointer move down

            # fill val to the right column
            for row in range(top, bottom+1):
                matrix[row][right] = val
                val += 1
            right -=1


            # fill val to the bottom row
            for col in range(right,left-1,-1):
                matrix[bottom][col]=val
                val += 1
            bottom -=1


            # fill val to the left column
            for row in range(bottom,top-1,-1):
                matrix[row][left]=val
                val +=1

            left += 1
        return matrix

```
        